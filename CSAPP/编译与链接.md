

#### 重定位的过程

```bash
$ objdump -dx main.o    

Disassembly of section .text:

0000000000000000 <main>:
   0:   f3 0f 1e fa             endbr64 
   4:   48 83 ec 08             sub    $0x8,%rsp
   8:   be 02 00 00 00          mov    $0x2,%esi
              # lea指令中后面放的立即数在链接前暂时放的是一个无效的地址
   d:   48 8d 3d [00 00 00 00]    lea    0x0(%rip),%rdi        # 14 <main+0x14>
                        10: R_X86_64_PC32       array-0x4
                        # 符号array的重定位条目，使用的是相对地址引用
                  
         # call指令中后面的立即数在链接前暂时放的是一个无效的地址
  14:   e8 00 00 00 00          callq  19 <main+0x19>
                        15: R_X86_64_PLT32      sum-0x4
                        # 符号sum的重定位条目，使用的
  19:   b8 00 00 00 00          mov    $0x0,%eax
  1e:   48 83 c4 08             add    $0x8,%rsp
  22:   c3                      retq  
```

在上面编译器生成的可重定位目标代码中，由于main函数中引用了数组array和sum函数，且暂时不知道这两个目标的最终内存地址，所以在生成的可重定位目标模块中有两条可重定位条目：

```bash
                     offset   type           symbol  addend
                        10: R_X86_64_PC32       array-0x4
                        15: R_X86_64_PLT32      sum-0x4
```

其中array的可重定位条目告诉我们这个符号引用的位置相对于段起始地址的偏移量为0x10，可重定位的类型为32位PC相对地址的引用，符号名为array，addend为-0x4。所以根据R_X86_64_PC32可重定位类型计算新的符号引用值的公式：
$$
符号引用新值=ADDR(r.symbol)+addend-符号引用地址
$$
在上面的array例子中符号引用新值应该放在相对函数main的0x10位置起始的4个字节的位置；而$ADDR(r.symbol)$这个array数组的地址我们是不知道的，不过不要紧我们在后面生成的可执行目标文件中进行确认；而后面的符号引用地址我们暂时也是不知道的，需要到最终生成的可执行文件中才能得知。所以为了验证上面公式的正确性，我们链接出了最终的可执行目标文件并进行反汇编查看：

```bash
$ objdump -dx main

0000000000001129 <main>:
    1129:       f3 0f 1e fa             endbr64 
    112d:       48 83 ec 08             sub    $0x8,%rsp
    1131:       be 02 00 00 00          mov    $0x2,%esi
                       # 链接器使用公式计算得到符号引用的新值并对其进行填充
    1136:       48 8d 3d [d3 2e 00 00]    lea    0x2ed3(%rip),%rdi        # 4010 <array>
    113d:       e8 0a 00 00 00          callq  114c <sum>
    1142:       b8 00 00 00 00          mov    $0x0,%eax
    1147:       48 83 c4 08             add    $0x8,%rsp
    114b:       c3                      retq   

000000000000114c <sum>:
    114c:       f3 0f 1e fa             endbr64 
    1150:       b8 00 00 00 00          mov    $0x0,%eax
    1155:       ba 00 00 00 00          mov    $0x0,%edx
    115a:       39 f0                   cmp    %esi,%eax
    115c:       7d 0b                   jge    1169 <sum+0x1d>
    115e:       48 63 c8                movslq %eax,%rcx
    1161:       03 14 8f                add    (%rdi,%rcx,4),%edx
    1164:       83 c0 01                add    $0x1,%eax
    1167:       eb f1                   jmp    115a <sum+0xe>
    1169:       89 d0                   mov    %edx,%eax
    116b:       c3                      retq   
    116c:       0f 1f 40 00             nopl   0x0(%rax)
```

从上面可执行目标文件反汇编生成的汇编代码可以看到，最终填进原来main函数中符号引用array的新值为0x2ed3，而实际链接为这个符号引用分配的地址为0x1139，显然带入上面的公式是成立的：
$$
0x2ed3==0x4010+(-0x4)-0x1139
$$
按照这个公式，我们也很容易验证书（CSAPP）中P478的话：**链接过程中的重定位主要由两步组成，①重定位段和符号定义；②然后重定位段中的符号引用。**

因此在链接的过程中，第一步完成了对代码段中函数地址的分配和数据段中全局变量的地址分配，因此我们知道了代码段的起始地址以及各个函数的起始地址，这样上面符号引用的地址显而易见就可以计算得到；同样的全局变量也就是符号引用所引用的符号地址也是可以确定的。因此根据这些知识，第二步过程通过带入公式计算很容易就可以得到，并对符号引用进行更新。



# CSAPP：链接与加载

## 1. 了解链接

### 1.1 链接的概念

描述链接的作用和链接相关的简单过程

链接就是将各种代码和数据片段收集并合并成一个单一文件的过程，这个文件可被加载到内存并执行。具体的，链接的过程可以发生在编译时（**传统的静态链接**），也可以发生在加载时（**加载时的共享库动态链接**），更甚之可以发生在运行时（**运行时的共享库动态链接**）。

C/C++程序从编写完成到可执行文件主要有如下几个步骤：

1. **预处理**：将文件中的宏、编译指令进行处理，相关命令`gcc -E`或`cpp`。
2. **编译**：将预处理后的文件经过词法分析和语法分析，翻译成汇编代码文件，相关命令`gcc -S`。
3. **汇编**：将汇编代码文件根据固定的汇编语言到二进制指令文件的翻译规则，转换成可重定位目标文件，相关命令`gcc -c`或`as`。
4. **链接**：将各个编译模块组合归并成可执行目标文件，相关命令`ld`。

![Snipaste_2021-09-04_16-19-24](image/Snipaste_2021-09-04_16-19-24.png)



### 1.2 静态链接

像上述这种将所有编译模块中的代码和数据都整合在同一个可执行目标文件的链接方式称为静态链接，有时也被称为完全链接。为了实现静态链接，静态链接器在链接的时候必须完成如下两个任务：

- **符号解析**：每一个编译模块都会定义和引用符号，每个符号对应于一个函数或是一个全局变量或是一个静态变量，而符号解析的目的就是将各个编译模块文件中的符号引用与一个符号定义关联起来。
- **重定位**：在编译的时候编译器和汇编器会生成从0地址开始的代码和数据节，当链接器完成符号解析之后，就会为每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置，填充上链接器为其分配的虚地址。具体的，链接器会利用汇编器产生的*重定位条目*来完成上述的目的。



## 2. 目标文件格式

目标文件主要有三种类型：

- **可重定位目标文件**：包含二进制代码和数据，它可以与其他可重定位目标文件进行合并从而生成下面的可执行目标文件。
- **可执行目标文件**：包含二进制代码和数据，其形式可以被直接复制到内存并执行。
- **共享目标文件**：一种特殊的可重定位目标文件，它可以在加载或只形式被动态的加载进内存并链接。

在Linux/Unix上目标文件采用可执行可链接格式ELF进行存储。



### 2.1 可重定位目标文件

<img src="image/relocatable-file.png" alt="relocatable-file" style="zoom: 67%;" />

上图展示了一个典型的可重定位目标文件ELF的格式内容。其中最开始部分的ELF头由如下几部分组成：

1. 描述该文件的系统字大小、字节序和机器类型

   （除此之外的内容，也就是下面的东西都是用来帮助链接器语法分析和解析目标文件信息）

2. ELF头大小、目标文件类型

3. 节头部表的文件偏移

4. 节头部表中条目的大小和数量

   （目标文件中的不同节的位置和大小都是由节头部表$Section\ Headers$来描述）

```bash
$ readelf main.o -h
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          784 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         14
  Section header string table index: 13
```



除了上述的ELF头之外，ELF可重定位目标文件主要有如下几个节组成：

|   节名称    |                             作用                             |
| :---------: | :----------------------------------------------------------: |
|   `.text`   |                 代码段，存放已编译的机器指令                 |
|  `.rodata`  |                    只读数据，如常量字符串                    |
|   `.data`   |                  已初始化的全局和静态C变量                   |
|   `.bss`    |                  未初始化的全局和静态C变量                   |
|  `.symtab`  |       符号表，存储程序中定义和引用的函数、全局变量信息       |
| `.rel.text` | 代码段的重定位条目信息，任何调用外部函数或引用外部全局变量<br />的指令都需要修改相关的地址并使用到这些条目 |
| `.rel.data` |        被模块引用或定义的所有全局变量的重定位条目信息        |

> 注意：符号表不存储局部变量的符号，它们完全没有必要链接器的参与，在地址和内容在编译的时候就已经确定了。

> 参考资料：https://luomuxiaoxiao.com/?p=192



### 2.2 符号与符号表

每一个可重定位目标文件都会有一个符号表`.symtab`，这个符号表在下面的符号解析过程中起到非常重要的作用。该表中主要包含如下三种类型的符号：

- **由模块m定义并能被其他模块引用的全局符号**：这些符号对应于非静态的全局函数和变量
- **由其他模块定义并被模块m所引用的全局符号**：这些符号对应外部模块定义的非静态全局函数和变量
- **只能被模块m定义和引用的局部符号**：这些符号对应本模块定义的静态全局/局部变量或函数

例如下面C文件中对应的符号表是长这样子的：

```c
extern int extern_global_value;
static int static_global_value;
int this_global_value;

int func(int v) {
        static int static_local_value = 2;
        return v + static_local_value + extern_global_value +
                        static_global_value + this_global_value;
}
```

```bash
$ readelf -s main.o

Symbol table '.symtab' contains 14 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
     5: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    4 static_global_value
     6: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    3 static_local_value.1916
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    8
    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
    11: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM this_global_value
    12: 0000000000000000    48 FUNC    GLOBAL DEFAULT    1 func
    13: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND extern_global_value
```

上面readelf命令输出的符号表有如下几个字段：

1. Num：用来指出这是当前模块中第几个符号
2. Value：表示该符号距定义目标节的起始位置的偏移量
3. Size：表示符号的字节大小
4. Type：表示指出该符号表示符号的类型，对象或函数，或者特别是文件，或者不知道的类型
5. Bind：表示符号是本地的还是全局的
6. Vis：表示可见性，一般都是默认可见性
7. Ndx：表示该符号被分配到目标文件的哪个节，实际上就是一个到节头部表的索引。但特别的会有三个特殊的伪节：
   1. ABS：表示该符号不该被重定位
   2. UND：表示该符号未定义
   3. COM：表示该符号是一个未分配未初始化的全局变量。在现代GCC中，未初始化的全局变量应该分配到COMMON段中，而未初始化的静态变量、初始化为0的全局变量和静态变量应该分配到`.bss`段中

在上面的C程序中：

1. `static_global_value`是一个未初始化的静态全局变量，所以根据符号表的描述我们可以知道它被分配在`.bss`段中；
2. `static_local_value`是一个显式初始化的局部静态变量，它被分配在`.data`段中；
3. `this_global_value`是一个未初始化的全局变量，它被分配在`COM`段中，这是一个伪节，我们不能保证它在程序运行之时有一个确定的初始值；
4. `func`是一个全局函数名，函数产生的二进制指令代码占48字节大小，根据Ndx字段描述我们可以知道它确实是分配在`.text`段中；
5. `extern_global_value`是一个外部全局变量，当前编译文件中没有它的定义，所以它被分配在伪节UNF段中。



### 2.3. 节头部表

如上所言，节头部表（*Section Headers Table*）记录着目标文件中的不同节的位置和大小，它对应可重定位目标文件的各个节的信息具有着非常重要的纵览作用。下面就展示了上一节源文件生成的可重定位目标文件中的节头部表：

```bash
$ readelf -S main.o
There are 13 section headers, starting at offset 0x390:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000030  0000000000000000  AX       0     0     1
  [ 2] .rela.text        RELA             0000000000000000  000002a8
       0000000000000060  0000000000000018   I      10     1     8
  [ 3] .data             PROGBITS         0000000000000000  00000070
       0000000000000004  0000000000000000  WA       0     0     4
  [ 4] .bss              NOBITS           0000000000000000  00000074
       0000000000000004  0000000000000000  WA       0     0     4
  [ 5] .comment          PROGBITS         0000000000000000  00000074
       000000000000002b  0000000000000001  MS       0     0     1
  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  0000009f
       0000000000000000  0000000000000000           0     0     1
  [ 7] .note.gnu.propert NOTE             0000000000000000  000000a0
       0000000000000020  0000000000000000   A       0     0     8
  [ 8] .eh_frame         PROGBITS         0000000000000000  000000c0
       0000000000000038  0000000000000000   A       0     0     8
  [ 9] .rela.eh_frame    RELA             0000000000000000  00000308
       0000000000000018  0000000000000018   I      10     8     8
  [10] .symtab           SYMTAB           0000000000000000  000000f8
       0000000000000150  0000000000000018          11    11     8
  [11] .strtab           STRTAB           0000000000000000  00000248
       000000000000005f  0000000000000000           0     0     1
  [12] .shstrtab         STRTAB           0000000000000000  00000320
       000000000000006c  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)
```

每一个节头部表中的条目分别记录了目标文件中各个节的名字、类型、地址、偏移量、节大小、条目大小、标志信息、链接信息和对齐等信息。



## 3. ==符号解析==

在上面的描述中我们已经阐明静态链接的过程中链接器主要会做两个重要的步骤，其中第一个就是符号的解析。链接器解析符号的方法就是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来，但是从具体的角度而言，又分成两种。一种是对目标模块内已定义的符号进行解析，显然这些符号的解析是容易的；另一种就是对全局符号的解析，编译器会假设该符号是在其他某个模块上定义，因此它会生成上一节中提到的符号表，这个表对于后续静态链接器的链接功能起到了非常重要的作用。

如果静态链接器在输入的多个编译模块中都找不到该全局符号的定义，那么链接器最终会输出一条错误信息：`undefined reference`。



### 3.1 多重定义解析规则





### 3.2 与静态库链接

#### 3.2.1 静态库的生成与链接

<img src="image/Snipaste_2021-09-05_10-01-47.png" alt="Snipaste_2021-09-05_10-01-47" style="zoom: 50%;" />

静态库指的是那些将所有相关的编译模块打包成要给单独的文件。当需要静态链接的时候，链接器会从静态库中复制被程序引用的目标模块。我们可以通过存档命令`ar`生成相应的静态库：

```bash
# 生成静态库
$ ar rcs libsum.a sumOfArr.o
# 链接使用静态库
$ gcc -o useSumOfArr useSumOfArr.c ./libsum.a -static
```

不过静态库也是存在非常大的缺点：一是它会造成每一个链接相同静态库的程序生成的可执行文件都会包含一些重复的目标模块数据，尤其是在完全链接的情况；二是一旦程序需要升级，实现发生了改变，即静态库发生了改变，那么我们就不得不对程序进行重新编译。

> 因此在实际中我们更多的是使用动态链接或者动态链接+静态链接的方式生成可执行文件。



#### 3.2.2 使用静态库进行符号解析

当我们需要对程序进行静态链接并处于符号解析的阶段时，链接器会从左到右按照它在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。在扫描的过程中，链接器会维护一个可重定位目标文件的集合$F$，一个未解析的符号集合$U$（未定义但已引用），一个在前面输入文件中已定义的符号集合$D$。然后链接器执行如下的步骤：

- 依次输入命令行上的文件$f$，判断它是否是目标文件还是存档文件（静态库）。若是目标文件，着将该文件$f$加入到集合$F$中，并修改未解析符号集合$U$和已解析符号集合$D$。
- 若是存档文件，那么链接器就会尝试匹配$U$中未解析的符号和由存档文件成员模块$m$定义的符号。如果某个存档文件成员模块$m$定义了相对应的符号，那么就将这个模块$m$加入到文件集合$F$中，并修改未解析符号集合$U$和解析符号集合$D$。
- 当链接器完成对命令行上输入文件的扫描后，如果$U$是非空的，那么链接器就会输出一个错误并终止。否则它会合并和重定位$F$中的目标文件，构建最终的可执行文件。

由于上述扫描的过程从左往右，如果一个目标文件引用的符号s的定义在前面一个目标文件中而不是后续目标文件中，那么链接就会出错，因此链接的时候对命令行上输入的文件是有顺序性的要求的。

> 最终，符号解析直观的结果就是所有输入目标文件的符号表会共同组成了一个全局的符号表，也即可执行目标文件中的符号表。



## 4. ==重定位==

当上述的符号解析完成之后，链接器就知道了最终的可执行文件中代码段和数据段需要多大的空间，因此它可以开始最后的内存空间分配工作，即重定位。在这个过程中，将合并输入模块，并未每一个符号分配运行时地址。重定位由如下步骤组成：

- <font color=green>**重定位节和符号定义**</font>：在这一步中，**链接器将所有相同类型的节合并成同一类型的新的聚合节，并为新的聚合节、聚合节中定义的符号（全局函数/变量）分配一个唯一的运行时内存地址**（可以认为该步骤又分成了节的重定位和符号定义的重定位这两步）。
- <font color=green>**重定位节中的符号引用**</font>：在这一步中，**链接器修改代码节和数据节中每一个符号引用，使得它们指向正确的运行时地址**，而这一步会利用到*重定位条目（relocation entry）*。

> 一般，前一步重定位符号定义处理的是数据段`.data`或`.bss`段中的内容，而后一步处理则是代码段`.text`中的内容。



### 4.1 重定位条目

当编译器生成一个目标模块时，它并不知道数据和代码最终会放在内存中的什么位置，它也不知道该模块引用的任何外部定义的函数或全局变量的位置。因此，汇编器一旦遇到对最终位置不可知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件的时候如何修改这些引用。

一般而言最为常见的就是`.rela.text`和`.rela.en_frame`。其中，`.rela.text`记录着代码段中引用的外部函数和全局变量的重定位条目；而`.rela.eh_frame`记录着`.eh_frame`（它以DWAF格式保存着一些调试信息）的重定位条目。由于符号引用一般只出现在代码中，所以我们经常看到最多的就是`.rela.text`，即代码段的重定位条目。

下面展示了之前符号表中提到的源文件生成的可重定位目标文件的重定位条目：

```bash
$ readelf -r main.o

Relocation section '.rela.text' at offset 0x2a8 contains 4 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000000d  000300000002 R_X86_64_PC32     0000000000000000 .data - 4
000000000018  000d00000002 R_X86_64_PC32     0000000000000000 extern_global_value - 4
000000000020  000400000002 R_X86_64_PC32     0000000000000000 .bss - 4
000000000028  000b00000002 R_X86_64_PC32     0000000000000004 this_global_value - 4

Relocation section '.rela.eh_frame' at offset 0x308 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000020  000200000002 R_X86_64_PC32    0000000000000000 .text + 0
```

其中重定位条目有如下字段：

1. Offset：表示该符号在被重定位节中的偏移量
2. Info：其高4字节表示该符号在符号表中的索引index，低4字节表示该引用的重定位类型
3. Type：就是对上述后4字节重定位类型的具现化描述
4. Sym.Value：符号值，暂不知具体作用
5. Sym.Name：符号名称
6. Addend：偏移调整量，一些重定位类型需要使用到它

其中上述的重定位类型Type对于如何重定位影响最大，一般我们最常见的就是PC相对寻址和绝对寻址：

- **R_X86_64_PC32**：重定位一个使用32位PC相对地址的引用。也就说使用一个PC相对地址来修改原来符号引用上的指令数据，其中PC相对寻址指的是距程序计数器PC当前运行位置的偏移量。
- **R_X86_64_32**：重定位一个使用32位绝对地址的引用。通过绝对寻址，CPU直接使用在指令编码中的32位值作为有效地址。

> 上述两种重定位类型支持x86-64小型代码模型，该模型假设可执行目标文件中数据和代码的总体大小都小于2GB，因此可以在运行时使用32位PC相对地址来访问。



### 4.2 重定位符号引用

#### 4.2.1 符号引用重定位算法

如上所言，当链接器执行完重定位节和符号定义之后，它就会使用重定位条目使得符号引用指向正确的运行时地址。而在这个过程中，符号引用的重定位类型对于符号引用最终的修改值是非常重要的，下面的伪代码展示了符号引用重定位算法：

```python
# 遍历每一个节/段
for s in sections:
    # 挨个处理每一个节中符号引用对应的重定位条目
    for en in s.relocation_entries:
        # 计算符号引用的地址
        refptr = s + r.offset
        
        # 如果重定位类型为32位PC相对寻址
        if en.type == R_X86_64_PC32:
            # 计算符号引用的运行时地址
            refaddr = ADDR(s) + en.offset
            # 将符号定义的地址 - 符号引用的运行时地址得到的相对地址作为符号引用的新值
            *refptr = (unsigned)(ADDR(en.symbol) + r.addend - refaddr)
            
        # 如果重定位类型为32位绝对地址
        if en.type == R_X86_64_32:
            # 将符号定义的绝对地址作为符号引用的新值
            *refptr = (unsigned)(ADDR(r.symbol) + r.addend)
```

对于每一个需要符号重定位的节而言，都会有一些相应的重定位条目与之相对，因此我们可以认为重定位条目的组成类似于一个二维数组（`sections = [[rela_ent00, .., rela_ent0N], .., [rela_entN0, ..]]`）（虽然实际中并不是这样的，但如此考虑会便于我们的理解）。其中，这个二维数组名为sections，即节，而每一个节都有一些对应需要使用到的重定位条目，即上面数组中的relocation entries。

当算法运行时链接器会逐节挨个处理每一个符号引用，并根据相应的重定位条目的重定位类型来做具体的重定位处理。为了展示这两种常见的重定位类型对符号引用重定位的影响，我们以如下的程序来进行演示：

```c
// main.c
int sum(int* arr, int n);

int array[2] = { 1, 2 };

int main() {
    int val = sum(array, 2);
    return 0;
}

// sum.c
int sum(int *arr, int n) {
    int s = 0;
    for(int i = 0; i < n; ++i)
        s += arr[i];
    return s;
}
```



#### 4.2.2 重定位PC相对引用

**链接前：**

上面的main.c程序生成的可重定位目标文件通过反汇编和ELF文件解析的方式产生了如下的汇编代码和重定位条目：

<img src="image/Snipaste_2021-09-05_16-35-03.png" alt="Snipaste_2021-09-05_16-35-03" style="zoom:80%;" />

```bash
$ readelf -a main.o

Section Headers:
  [Nr] Name              Type             Address           Offset  
       Size              EntSize          Flags  Link  Info  Align  
  ...
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000027  0000000000000000  AX       0     0     1   
  [ 2] .rela.text        RELA             0000000000000000  00000260
       0000000000000030  0000000000000018   I      10     1     8   
  [ 3] .data             PROGBITS         0000000000000000  00000068
       0000000000000008  0000000000000000  WA       0     0     8   
  [ 4] .bss              NOBITS           0000000000000000  00000070
       0000000000000000  0000000000000000  WA       0     0     1

Relocation section '.rela.text' at offset 0x260 contains 2 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000014  000900000002 R_X86_64_PC32     0000000000000000 array - 4
000000000019  000c00000004 R_X86_64_PLT32    0000000000000000 sum - 4

Relocation section '.rela.eh_frame' at offset 0x290 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0

Symbol table '.symtab' contains 13 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
    ...
     9: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 array
    10: 0000000000000000    39 FUNC    GLOBAL DEFAULT    1 main
    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_
    12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND sum
```

从上面的结果可以看到在编译汇编之后、链接之前可重定位目标文件中一旦二进制指令涉及到一个符号引用，由于在链接之前无法确定具体的运行时地址，因此相应的指令内容都会被填充为0，等待后续链接——重定位符号引用阶段由链接器进行修改，使其指向正确的地址。

在该程序中主要有两个符号引用需要在链接——重定位符号引用阶段进行处理：一个是全局数组array，另一个是外部全局函数sum，前者正是使用了PC32位相对寻址方式来重定位的。



**链接时：**

在链接器执行到重定位符号引用阶段时，链接器会查看全局数组array的重定位条目，其内容为：

1. 距所在节的offset为`0x14`：根据重定位条目Info高4字节——>再查符号表的所在节索引Ndx——>再查节头部表可以知道这个节指的是数据段`.data`。
2. 偏移调整量addend为`-4`。
3. 重定位类型为PC32相对寻址。

由于在前面的符号定义重定位阶段已经为符号的定义生成了唯一的运行时地址，因此我们知道array的内存地址为`0x4010`，代码段`.text`的起始地址为`0x1129`，所以我们首先计算得到main函数中对array的符号引用的地址为：
$$
refaddr = ADDR(.text) + ent.offset \\
= 0x1129 + 0x14 = 0x113d
$$
 然后链接器接着计算该符号引用相对于全局变量array的32位PC相对地址：
$$
relative\ addr = (unsigned)(ADDR(array) + ent.addend - refaddr) \\
= (unsigned)(0x4010 + (-4) - 0x113d) = 0x2ecf
$$
计算完成后我们就得到了原来符号引用array的二进制指令中需要填充的内容了，此时我们就可以将其赋给`*refptr`了。



**链接后：**

此时我们再来检查链接完成之后的可执行目标文件的反汇编指令，就可以看到原来符号引用array上填充的0000..被填充上了`0x00002ecf`：

<img src="image/Snipaste_2021-09-05_17-14-22.png" alt="Snipaste_2021-09-05_17-14-22" style="zoom: 80%;" />





#### 4.2.3 重定位绝对引用

> 由于上面的程序没有出现绝对引用的重定位类型，因此我们这里就不演示这种重定位类型了。



### 4.3 静态链接过程总结

一个程序文件从编写完毕、预处理、编译、汇编、静态链接，到最终的可执行目标文件的生成有着如下的大致过程：

<img src="image/编译汇编链接.png" alt="编译汇编链接" style="zoom:80%;" />



## 5. 可执行目标文件

### 5.1 可执行目标文件格式

下面展示了一个链接生成的可执行目标文件的ELF文件结构：

![Snipaste_2021-09-05_17-58-29](image/Snipaste_2021-09-05_17-58-29.png)

与可重定位目标文件相似，可执行目标文件中仍然存在着`.text`、`.rodata`、`.data`、`.bss`、`.symtab`、段头部表等内容。不过与之前相比，可执行目标文件中有了一些如下的不同之处：

1. ELF头中的程序的入口点不再是0，而是变成了程序第一条指令的地址。如下所示：

   ```bash
   $ readelf -h main
   ELF Header:
     Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
     ...
     Entry point address:               0x1040  # ELF头中指出的程序第一条指令地址
     Start of program headers:          64 (bytes into file)
     ...
   
   $ objdump -d main        
   
   ...
   
   Disassembly of section .text:
   
   0000000000001040 <_start>:  # 程序第一个需要执行的过程_start的起始地址正好是0x1040
       1040:       f3 0f 1e fa             endbr64
       1044:       31 ed                   xor    %ebp,%ebp
       1046:       49 89 d1                mov    %rdx,%r9
       1049:       5e                      pop    %rsi
   ```

2. 会存在一个`.init`的节，内部含有一个名为`_init()`的小函数，会在程序初始化的时候得到执行。

3. 由于上述操作下的可执行目标文件是完全链接的，所以不会再存在重定位条目，即不会再有`.rela`节。

4. ELF可执行文件中连续的片chunk会被映射到连续的内存段，因此会使用名为程序头部表（也叫段头部表）的结构来记录这一信息：

   ```bash
   $ readelf -l main 
   
   Program Headers:
     Type           Offset             VirtAddr           PhysAddr
                    FileSiz            MemSiz              Flags  Align     
     PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                    0x00000000000002d8 0x00000000000002d8  R      0x8       
     INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                    0x000000000000001c 0x000000000000001c  R      0x1       
         [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]      
     LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                    0x00000000000005c8 0x00000000000005c8  R      0x1000    
     LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                    0x0000000000000225 0x0000000000000225  R E    0x1000
     LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                    0x0000000000000158 0x0000000000000158  R      0x1000
     LOAD           0x0000000000002df0 0x0000000000003df0 0x0000000000003df0
                    0x0000000000000228 0x0000000000000230  RW     0x1000
     DYNAMIC        0x0000000000002e00 0x0000000000003e00 0x0000000000003e00
                    0x00000000000001c0 0x00000000000001c0  RW     0x8
     NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338
                    0x0000000000000020 0x0000000000000020  R      0x8
     NOTE           0x0000000000000358 0x0000000000000358 0x0000000000000358
                    0x0000000000000044 0x0000000000000044  R      0x4
     GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338
                    0x0000000000000020 0x0000000000000020  R      0x8
     GNU_EH_FRAME   0x0000000000002004 0x0000000000002004 0x0000000000002004
                    0x0000000000000044 0x0000000000000044  R      0x4
     GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                    0x0000000000000000 0x0000000000000000  RW     0x10
     GNU_RELRO      0x0000000000002df0 0x0000000000003df0 0x0000000000003df0
                    0x0000000000000210 0x0000000000000210  R      0x1
   
   # 这也提示我们section节和segment段是不一样的概念
    Section to Segment mapping:
     Segment Sections...
      00
      01     .interp
      02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn
      03     .init .plt .plt.got .text .fini
      04     .rodata .eh_frame_hdr .eh_frame
      05     .init_array .fini_array .dynamic .got .data .bss
      06     .dynamic
      07     .note.gnu.property
      08     .note.gnu.build-id .note.ABI-tag
      09     .note.gnu.property
      10     .eh_frame_hdr
      11
      12     .init_array .fini_array .dynamic .got
   ```

   上面的程序头部表显示可执行文件被加载后会映射到13个内存段中，每一个段都会使用程序头部表的字段来进行描述：

   1. Type：段的类型
   2. Offset：本段在目标文件中的偏移
   3. VirtAddr/PhysAddr：本段的虚拟/物理内存地址
   4. FileSiz：本段在目标文件中的大小
   5. MemSiz：本段在内存中的大小
   6. Flags：本段的权限标志（读写）
   7. Align：本段的内存对齐要求

   一般来说可执行目标文件可能存在一个节映射到一个内存段中，也可能存在多个节映射到一个内存段中。例如在上述的可执行目标文件中，`.init`、`.plt`、`.plt.got`、`.text`、`.fini`这多个节都被映射到了编号为03的内存段中，权限标志告诉我们这个段可读不可写。



### 5.2 加载可执行目标文件

当我们在命令行中输入了可执行目标文件时，就开始了程序的加载过程，在这期间它会执行如下的步骤：

1. shell程序调用fork程序创建子进程，并分配、复制父进程的地址空间。
2. 子进程调用execve系统调用启动加载器。
3. 加载器删除子进程中现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段，新的栈段和堆段会被初始化为0。
4. 通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码段和数据段被初始化为可执行文件的内容。
5. 接着，加载器跳转到程序的入口地址，即_start函数的地址，该函数会调用`__libc_start_main`函数，完成执行环境的初始化，并调用用户层的main函数，并在最后处理main函数的返回值，并且在需要的时候把控制返回给内核。

如下是Linuxx86-64程序加载完成后运行的内存映像：

![Snipaste_2021-09-06_11-19-55](image/Snipaste_2021-09-06_11-19-55.png)



## 6. 动态链接库

### 6.1 了解动态链接

从上面的内容中我们已经了解到静态链接的原理，可以看到静态链接很好的将分离式编译、接口和实现分离的观点进行贯彻。不过它的缺点也是很多，最大的两点就是更新实现时必须重新链接以及对硬盘和内存空间的浪费，因此有了共享库。

共享库也是一个目标模块，但它可以在运行或加载时加载到任意的内存地址，并和在内存中的程序进行链接起来。这个过程称为动态链接，由名为动态链接器（`/lib64/ld-linux-x86-64.so.2`）的程序来负责执行。如我们所言，动态链接库可以保证在程序运行的过程中，即使有多个程序链接到它，内存中也仅会有一个共享库副本，程序/可执行文件本身也不会像静态链接那样复制共享库中的数据和代码。

动态库的创建和链接如下所示：





### 6.2 加载时链接



### 6.3 运行时链接



### 6.4 位置无关代码



## 7. 库打桩机制

>  库打桩机制这个中文名字很容易让初学者一头雾水，根据英文原名library interpositioning，最好翻译成库干涉机制这样的名字其实是最好的。

库打桩机制的目的很简单，就是**允许用户截获对共享库中的函数调用，并取而代之执行自己的代码**。

例如在腾讯的开源协程库libco实现中就是用了库打桩机制，使得程序在执行可能会阻塞进程的Linux系统调用之前对其进行截获，转而执行libco库中自己定义的同名函数，直到程序确定此时调用这个函数不会导致进程进入阻塞状态的时候才会调用这个函数，从而避免进程进入阻塞状态。不过该项目并没有称之为库打桩技术，而是使用了hook这个名字。



### 7.1 编译时打桩





### 7.2 链接时打桩



### 7.3 运行时打桩



