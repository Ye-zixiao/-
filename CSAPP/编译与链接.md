

#### 重定位的过程

```bash
$ objdump -dx main.o    

Disassembly of section .text:

0000000000000000 <main>:
   0:   f3 0f 1e fa             endbr64 
   4:   48 83 ec 08             sub    $0x8,%rsp
   8:   be 02 00 00 00          mov    $0x2,%esi
              # lea指令中后面放的立即数在链接前暂时放的是一个无效的地址
   d:   48 8d 3d [00 00 00 00]    lea    0x0(%rip),%rdi        # 14 <main+0x14>
                        10: R_X86_64_PC32       array-0x4
                        # 符号array的重定位条目，使用的是相对地址引用
                  
         # call指令中后面的立即数在链接前暂时放的是一个无效的地址
  14:   e8 00 00 00 00          callq  19 <main+0x19>
                        15: R_X86_64_PLT32      sum-0x4
                        # 符号sum的重定位条目，使用的
  19:   b8 00 00 00 00          mov    $0x0,%eax
  1e:   48 83 c4 08             add    $0x8,%rsp
  22:   c3                      retq  
```

在上面编译器生成的可重定位目标代码中，由于main函数中引用了数组array和sum函数，且暂时不知道这两个目标的最终内存地址，所以在生成的可重定位目标模块中有两条可重定位条目：

```bash
                     offset   type           symbol  addend
                        10: R_X86_64_PC32       array-0x4
                        15: R_X86_64_PLT32      sum-0x4
```

其中array的可重定位条目告诉我们这个符号引用的位置相对于段起始地址的偏移量为0x10，可重定位的类型为32位PC相对地址的引用，符号名为array，addend为-0x4。所以根据R_X86_64_PC32可重定位类型计算新的符号引用值的公式：
$$
符号引用新值=ADDR(r.symbol)+addend-符号引用地址
$$
在上面的array例子中符号引用新值应该放在相对函数main的0x10位置起始的4个字节的位置；而$ADDR(r.symbol)$这个array数组的地址我们是不知道的，不过不要紧我们在后面生成的可执行目标文件中进行确认；而后面的符号引用地址我们暂时也是不知道的，需要到最终生成的可执行文件中才能得知。所以为了验证上面公式的正确性，我们链接出了最终的可执行目标文件并进行反汇编查看：

```bash
$ objdump -dx main

0000000000001129 <main>:
    1129:       f3 0f 1e fa             endbr64 
    112d:       48 83 ec 08             sub    $0x8,%rsp
    1131:       be 02 00 00 00          mov    $0x2,%esi
                       # 链接器使用公式计算得到符号引用的新值并对其进行填充
    1136:       48 8d 3d [d3 2e 00 00]    lea    0x2ed3(%rip),%rdi        # 4010 <array>
    113d:       e8 0a 00 00 00          callq  114c <sum>
    1142:       b8 00 00 00 00          mov    $0x0,%eax
    1147:       48 83 c4 08             add    $0x8,%rsp
    114b:       c3                      retq   

000000000000114c <sum>:
    114c:       f3 0f 1e fa             endbr64 
    1150:       b8 00 00 00 00          mov    $0x0,%eax
    1155:       ba 00 00 00 00          mov    $0x0,%edx
    115a:       39 f0                   cmp    %esi,%eax
    115c:       7d 0b                   jge    1169 <sum+0x1d>
    115e:       48 63 c8                movslq %eax,%rcx
    1161:       03 14 8f                add    (%rdi,%rcx,4),%edx
    1164:       83 c0 01                add    $0x1,%eax
    1167:       eb f1                   jmp    115a <sum+0xe>
    1169:       89 d0                   mov    %edx,%eax
    116b:       c3                      retq   
    116c:       0f 1f 40 00             nopl   0x0(%rax)
```

从上面可执行目标文件反汇编生成的汇编代码可以看到，最终填进原来main函数中符号引用array的新值为0x2ed3，而实际链接为这个符号引用分配的地址为0x1139，显然带入上面的公式是成立的：
$$
0x2ed3==0x4010+(-0x4)-0x1139
$$
按照这个公式，我们也很容易验证书（CSAPP）中P478的话：**链接过程中的重定位主要由两步组成，①重定位段和符号定义；②然后重定位段中的符号引用。**

因此在链接的过程中，第一步完成了对代码段中函数地址的分配和数据段中全局变量的地址分配，因此我们知道了代码段的起始地址以及各个函数的起始地址，这样上面符号引用的地址显而易见就可以计算得到；同样的全局变量也就是符号引用所引用的符号地址也是可以确定的。因此根据这些知识，第二步过程通过带入公式计算很容易就可以得到，并对符号引用进行更新。



# CSAPP：链接与加载

## 1. 链接的概念

描述链接的作用和链接相关的简单过程



## 2. 静态链接



## 3. 目标文件格式

### 3.1 可重定位目标文件



### 3.2 符号与符号表



## 4. ==符号解析==

一是对目标模块内部已定义的符号进行解析（例如局部static符号的解析），由于这些符号基本上在本模块中就已经基本确定了，所以它们的符号解析基本上编译器就可以解决。二是需要对那些在当前目标模块中未定义符号的解析，这些符号引用的解析相对而言比较麻烦一些，需要链接器的参与。

### 4.1 多重定义解析规则





### 4.2 与静态库链接



### 4.3 解析符号引用方法



## 5. ==重定位==

### 5.1 重定位条目



### 5.2 重定位符号引用



## 6. 可执行目标文件

### 6.1 可执行目标文件格式



### 6.2 加载可执行目标文件



## 7. 动态链接库

### 7.1 加载时链接



### 7.2 运行时链接



### 7.3 位置无关代码



## 8. 库打桩机制

>  库打桩机制这个中文名字很容易让初学者一头雾水，根据英文原名library interpositioning，最好翻译成库干涉机制这样的名字其实是最好的。

库打桩机制的目的很简单，就是**允许用户截获对共享库中的函数调用，并取而代之执行自己的代码**。

例如在腾讯的开源协程库libco实现中就是用了库打桩机制，使得程序在执行可能会阻塞进程的Linux系统调用之前对其进行截获，转而执行libco库中自己定义的同名函数，直到程序确定此时调用这个函数不会导致进程进入阻塞状态的时候才会调用这个函数，从而避免进程进入阻塞状态。不过该项目并没有称之为库打桩技术，而是使用了hook这个名字。



### 8.1 编译时打桩





### 8.2 链接时打桩



### 8.3 运行时打桩



