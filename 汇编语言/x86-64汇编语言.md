# x86-64汇编语言

## 一、寄存器

### 1.1 通用目的寄存器

| 寄存器 |      功能      | 参数寄存器 | 调用时是否需要保存 |
| :----: | :------------: | :--------: | :----------------: |
| `%rax` | 累加器、返回值 |            |                    |
| `%rbx` |   基址寄存器   |            |    被调函数保存    |
| `%rcx` |     计数器     |  第四参数  |                    |
| `%rdx` |   数据寄存器   |  第三参数  |                    |
| `%rsi` |  源索引寄存器  |  第二参数  |                    |
| `%rdi` | 目的索引寄存器 |  第一参数  |                    |
| `%rbp` |    栈基指针    |            |    被调函数保存    |
| `%rsp` |    栈顶指针    |            |                    |
| `%r8`  |                |  第五参数  |                    |
| `%r9`  |                |  第六参数  |                    |
| `%r10` |                |            |     调用者保存     |
| `%r11` |                |            |     调用者保存     |
| `%r12` |                |            |    被调函数保存    |
| `%r13` |                |            |    被调函数保存    |
| `%r14` |                |            |    被调函数保存    |
| `%r15` |                |            |    被调函数保存    |

<img src="image/Snipaste_2021-05-27_15-43-40.png" alt="Snipaste_2021-05-27_15-43-40" style="zoom:67%;" />

其中`%r8`~`%r15`这部分的寄存器都是自x86-64体系架构之后引入进来的，在此之前的IA-32并不使用它们。除此之外，大多数x86CPU GPR寄存器的由来都是有一定的历史渊源的，从8086CPU设计之初就一直存在，我们可以通过如下的8086CPU结构大致的了解到各个寄存器的作用。

<img src="image/8086寄存器.jpg" alt="8086寄存器" style="zoom:50%;" />



### 1.2 段寄存器



### 1.3 EFLAGS寄存器

EFLAGS寄存器也被称为标志寄存器或者条件码寄存器，下面我都以标志寄存器进行称呼之。

<img src="image/Snipaste_2021-05-27_21-04-51.png" alt="Snipaste_2021-05-27_21-04-51" style="zoom:65%;" />

其中最常用的标志位有如下几个：

| 标志位 |          作用          |
| :----: | :--------------------: |
|   CF   |        进位标志        |
|   PF   |        奇偶标志        |
|   AF   |      辅助进位标志      |
|   ZF   |         零标志         |
|   SF   |        符号标志        |
|   TF   | 陷阱标志(单步中断标志) |
|   IF   |        中断标志        |
|   DF   |        方向标志        |
|   OF   |        溢出标志        |
|  IOPL  |     I/O特权级别域      |



### 1.3 寻址模式

在x86-64中，操作数或寻址方式主要是通过如下三种方式给出：①立即数$\$Imm$；②寄存器$r_a$；③内存引用$(r_a)$。不过实际中它提供了非常多的寻址模式，一种最为通用的方式可以用如下的公式表示：
$$
Imm(r_b,r_i,s)=Imm+R[r_b]+R[r_i]\times{s}
$$

其中Imm是立即数，$r_b$是基址寄存器中的值，$r_i$是变址寄存器中的值，s是比例因子，这种通用的寻址模式在内存数组元素中非常常见，不过更多的是它的衍生方式。下面展示了所有的寻址模式：

|  类型  |       格式       |          操作数          |      名称       |
| :----: | :--------------: | :----------------------: | :-------------: |
| 立即数 |     $\$Imm$      |          $Imm$           |   立即数寻址    |
| 寄存器 |      $r_a$       |         $R[r_a]$         |   寄存器寻址    |
| 存储器 |      $Imm$       |         $M[Imm]$         |    绝对寻址     |
| 存储器 |     $(r_a)$      |       $M[R[r_a]]$        |    间接寻址     |
| 存储器 |    $Imm(r_a)$    |     $M[Imm+R[r_b]]$      | 基址+偏移量寻址 |
| 存储器 |   $(r_b,r_i)$    |    $M[R[r_b]+R[r_i]]$    |    变址寻址     |
| 存储器 |  $Imm(r_b,r_i)$  |  $M[Imm+R[r_b]+R[r_i]]$  |    变址寻址     |
| 存储器 |    $(,r_i,s)$    |      $M[R[r_i]*s]$       |  比例变址寻址   |
| 存储器 |  $Imm(,r_i,s)$   |    $M[Imm+R[r_i]*s]$     |  比例变址寻址   |
| 存储器 |  $(r_b,r_i,s)$   |   $M[R[r_b]+R[r_i]*s]$   |  比例变址寻址   |
| 存储器 | $Imm(r_b,r_i,s)$ | $M[Imm+R[r_b]+R[r_i]*s]$ |  比例变址寻址   |



## 二、汇编指令

### 2.1 数据传送指令

#### 2.1.1 MOV指令

在x86-64汇编语言中我们可以通过如下指令来实现数据在寄存器、存储器或者自立即数之间的数据交换操作：

- **MOV S, D系列指令**：实现将源S中的数据传送到目的位置D中，不过x86-64要求源和目的都不能指向存储器内存位置！
- **MOVZ S，D系列指令**：这种指令和下面的MOVS指令类似，适用于将较小的源值复制到较大的目的时使用，至于怎么填充高端字节位置各有各的不同。在这里MOVZ的作用是将高端字节置为0；
- **MOVS S，D系列指令**：这种指令与MOVZ不同，它是将高端字节按照较小的源中存储的数据的符号位进行填充。

下面仅展示MOV系列指令：

|   指令    | 效果 |        功能        |
| :-------: | :--: | :----------------: |
|  `movb`   | S->D |      传送字节      |
|  `movw`   | S->D | 传送字（两个字节） |
|  `movl`   | S->D |      传送双字      |
|  `movq`   | S->D |      传送四字      |
| `movabsq` | I->R |   传送绝对的四字   |



#### 2.1.2 栈操作指令

x86-64体系中只有4字的压栈和出栈操作指令，其中栈的所在（或者说栈的边界）由栈基指针%rbp和栈顶指针%rsp定位。

|   指令    |                  效果                   |      功能      |
| :-------: | :-------------------------------------: | :------------: |
| `pushq S` | `R[%rsp]=R[%rsp]-8`<br />`M[R[%rsp]]=S` |   将四字压栈   |
| `popq D`  | `D=M[R[%rsp]]`<br />`R[%rsp]=R[%rsp]+8` | 从栈中弹出四字 |



### 2.2 算术与逻辑操作指令

#### 2.2.1 加载有效地址

加载有效地址leaq（load effective address）指令虽然听上去是一个取内存单元地址的指令，但实际上它常常用作算术运算指令，而且它常常和上面所述的“寻址模式通用范式”一起使用。

|    指令     | 效果  |         功能         |
| :---------: | :---: | :------------------: |
| `leaq S, D` | &S->D | 加载内存单元有效地址 |

例如当我们使用如下指令的时候：

```asm
leaq Imm(%rdi, %rsi, s),  %rax
```

其产生的效果并不是将$M[Imm+R[\%rdi]+R[\%rsi]*s]$这块内存单元中的数据加载到%rax寄存器中，实际产生的效果是将这一内存单元的有效地址，也就是$Imm+R[\%rdi]+R[\%rsi]*s$这一地址传送到%rax寄存器中。

实际上，它在做的是一个算术操作，如果我们将$R[\%rdi]$记作x，将$R[\%rsi]$记作y，那么这个`leaq`指令可以完成$Imm+x+s\times{y}$的复合运算，这显然比下面介绍的`mul`、`add`等指令高级了很多！最后将结果存放到%rax寄存器中。这也是为什么一个取地址的指令会被分类到算术运算指令的缘故。



#### 2.2.2 算术操作指令

算术操作主要有一元操作和二元操作两种，且每一种都有适用于不同字/字节大小的b/w/l/q等变种，如下表所示：

|         指令         |         效果          |   功能   |
| :------------------: | :-------------------: | :------: |
|   `inc(b/w/l/q) D`   |         D=D+1         |   自增   |
|   `dec(b/w/l/q) D`   |         D=D-1         |   自减   |
|  `neg(b/w/l/q) D `   |         D=-D          |   取负   |
|   `not(b/w/l/q) D`   |         D=~D          |   取反   |
| `add(b/w/l/q) S, D`  |         D=D+S         |    加    |
| `sub(b/w/l/q) S, D`  |         D=D-S         |    减    |
| `imul(b/w/l/q) S, D` |         D=D*S         | 有符号乘 |
|  `idiv(b/w/l/q)  S`  | $R[\%rax]=R[\%rax]/S$ | 有符号除 |
| `xor(b/w/l/q) S, D`  |        D=D ^ S        |   异或   |
|  `or(b/w/l/q) S, D`  |       D=D \| S        |    或    |
| `and(b/w/l/q) S, D`  |         D=D&S         |    与    |

> 注意：使用指定的x86-64指令的时候一定要使用对应大小的寄存器。例如视图对%eax进行取反，就不能使用negq，必须使用negl！如果不想犯这个错误，那么我们实际上可以使用干脆地不指定字节或者字的大小，例如对于前面的例子我们可以直接使用neg，而不是negq就不会犯错了。



#### 2.2.3 移位操作指令

x86-64汇编语言包含如下的常见的移位操作（其中sal和sar中的a表示算术Arithmetic，而shl和shr是用来表示逻辑移位的，即指的对最高位不加考虑的无符号形式，所以也叫做无符号移位）：

|        指令         |      效果       |       功能       |
| :-----------------: | :-------------: | :--------------: |
| `sal(b/w/l/q) k, D` |     D<-D<<k     |       左移       |
| `shl(b/w/l/q) k, D` |     D<-D<<k     | 左移（与上相同） |
| `sar(b/w/l/q) k, D` |     D<-D>>k     |       右移       |
| `shr(b/w/l/q) k, D` |     D<-D>>k     | 右移（与上相同） |
| `rol(b/w/l/q) k, D` | D<-D<<(rotate)k |     循环左移     |
| `ror(b/w/l/q) k, D` | D<-D>>(rotate)k |     循环右移     |

其中移位值可以是一个立即数，或者也可以放在寄存器%cl（必须是该寄存器）中给出。在x86-64体系中，移位操作有一个比较麻烦的规则：如果移位操作是对一个w位长的数据值进行操作，那么移位量就会由%cl寄存器中的低m位决定，其中$2^m=w$。

也就说，若%cl寄存器中的数据为0xFF（即1111 1111），那么若使用`salb %cl, %al`，那么由于操作的是一个8位长度寄存器，所以由于$2^3=8$，所以CPU只会取%cl中的低3位。而正由于%cl中的低3位是111b，所以%al左移7位！



#### 2.2.4 其他特殊算术指令

除了上述的一些常见的算术指令之外，x86-64汇编指令还支持一些其他的特殊算术指令，包括一元操作的无符号乘法、一元操作的有符号乘法、二元操作的乘法等等。具体如下表所示：

|         指令         |                        描述                         |             功能              |
| :------------------: | :-------------------------------------------------: | :---------------------------: |
|   `mul(b/w/l/q) S`   |                $R[\%rax]=R[\%rax]*S$                |        一元无符号乘法         |
|  `imul(b/w/l/q) S`   |                $R[\%rax]=R[\%rax]*S$                |     一元有符号(补码)乘法      |
| `imul(b/w/l/q) S, D` |                       D<=D*S                        |           二元乘法            |
|   `div(b/w/l/q) S`   | $R[\%rax]=R[\%rax]/S$<br />$R[\%rdx]=R[\%rax]mod S$ |        一元无符号除法         |
|  `idiv(b/w/l/q) S`   | $R[\%rax]=R[\%rax]/S$<br />$R[\%rdx]=R[\%rax]mod S$ |        一元有符号除法         |
|        `cqto`        |      $R[\%rdx]:R[\%rax]$<-$符号拓展(R[\%rax])$      | 将%rax符号拓展成8字(用于除法) |

> 对于上面的指令，特别需要注意下除法指令被除数、结果的存放，以及它们实际操作的被除数达到的位数。实际上被除数一般就是操作指令的所表达的位数的两倍，结果也是操作指令所表达的位数的两倍，分别都是存放在%?dx和%?ax中。



### 2.3 控制流指令

#### 2.3.1 条件码和比较指令

在x86-64汇编指令中，绝大多数算术和逻辑操作指令（除了leaq指令）的执行结果都有可能会影响到上述标志寄存器中的条件码，最常用的条件码包括如下4个要素，它们是进行分支跳转时的有效依据：

1. CF：进位标志
2. ZF：零标志
3. SF：符号标志
4. OF：溢出标志

在x86汇编指令中，基于条件码的分支跳转更多的是依靠cmp和test这两类指令而不是算术逻辑操作指令，因为它们并不会改变任何寄存器中的值，只会设置标志寄存器中的标志位。就功能而言，cmp类指令功能更像是sub指令；test类指令功能更像是and指令。这两类寄存器如下所示：

|      指令      |    描述    |   功能   |
| :------------: | :--------: | :------: |
| `cmpb S1, S2`  | $S_1-S_2$  | 比较字节 |
| `cmpw S1, S2`  | $S_1-S_2$  |  比较字  |
| `cmpl S1, S2`  | $S_1-S_2$  | 比较双字 |
| `cmpq S1, S2`  | $S_1-S_2$  | 比较四字 |
| `testb S1, S2` | $S_1\&S_2$ | 测试字节 |
| `testw S1, S2` | $S_1\&S_2$ |  测试字  |
| `testl S1, S2` | $S_1\&S_2$ | 测试双字 |
| `testq S1, S2` | $S_1\&S_2$ | 测试四字 |



#### 2.3.2 转移指令





#### 2.3.3 条件控制指令

对于标志寄存器而言，任务标志位都是不能直接读取，其主要常用来在其他的控制指令上起作用。最常用的使用方法有如下三种：

- 根据条件码的某种组合将一个字节设置为0或者1，也叫做条件置位
- 根据条件码进行分支跳转，也叫做条件转移
- 根据条件码进行数据传送，也叫做条件传送



##### 2.3.3.1 条件置位指令

条件置位指令如上所述指的就是根据标志寄存器中条件码反应的情况将给定的单字节寄存器或者存储器元素置为0或者1，常见的部分如下所示：

|   指令    | 同义指令 |         效果         |       设置条件       |
| :-------: | :------: | :------------------: | :------------------: |
| `sete D`  |  `setz`  |       D <- ZF        |       相等/零        |
| `setne D` | `setnz`  |       D <- ~ZF       |      不等/非零       |
| `sets D`  |          |       D <- SF        |         负数         |
| `setns D` |          |       D <- ~SF       |        非负数        |
| `setg D`  | `setnle` | D <- \~(SF^OF)\&\~ZF |    >大于(有符号)     |
| `setge D` | `setnl`  |    D <- ~(SF^OF)     |  >=大于等于(有符号)  |
| `setl D`  | `setnge` |      D <- SF^OF      |    <小于(有符号)     |
| `setle D` | `setng`  |  D <- \~(SF^OF)\|ZF  |  <=小于等于(有符号)  |
| `seta D`  | `setnbe` |    D <- \~CF&\~ZF    |    >超过(无符号)     |
| `setae D` | `setnb`  |      D <- \~CF       | >=超过或等于(无符号) |
| `setb D`  | `setnae` |       D <- CF        |    <低于(无符号)     |
| `setbe D` | `setna`  |     D <- CF\|ZF      | <=低于或等于(无符号) |



##### 2.3.3.2 条件转移指令



##### 2.3.3.3 条件传送指令



### 2.4 其他指令



## 三、过程调用





## 四、参考资料

1. [维基百科-x86 Assembly](https://en.wikibooks.org/wiki/X86_Assembly#Table_of_Contents)
2. [深入理解计算机系统CSAPP](https://en.wikibooks.org/wiki/X86_Assembly#Table_of_Contents)

